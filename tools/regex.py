from typing import List


class Node():
    """ Node of the syntax tree generated by the RegExpParser class """

    def __init__(self, symbol: str, left, right, label) -> None:
        if symbol == '.' and left is None:
            self.symbol = right.symbol
            self.left = right.left
            self.right = right.right
        else:
            self.symbol = symbol
            self.left = left
            self.right = right
        self.label = label

    def __str__(self):
        return self.symbol + str(self.label)


class RegExpParser():
    """ Recursive descent regex parser """

    def __init__(self, regex: str) -> None:
        self._input_regex = regex
        self._pos = 0  # position of the next symbol
        self._nodes = 0  # number nodes created, used to label them

    def parse(self) -> Node:
        """ Returns the root node of the regex syntax tree """
        try:
            root = self._regex()
        except IndexError:
            raise RuntimeError("Invalid regex")

        if self._pos != len(self._input_regex):
            raise RuntimeError("Invalid regex")

        return root

    def _peek(self) -> str:
        return self._input_regex[self._pos]

    def _eat(self, char: str) -> None:
        if self._peek() == char:
            self._pos += 1
        else:
            raise RuntimeError("Invalid regex")

    def _follow(self) -> str:
        char = self._peek()
        self._eat(char)
        return char

    def _more(self) -> bool:
        return self._pos < len(self._input_regex)

    def _regex(self) -> Node:
        # <regex> ::= <term> '|' <regex> | <term>
        term = self._term()
        if self._more() and self._peek() == '|':
            self._eat('|')
            regex = self._regex()
            self._nodes += 1
            return Node('|', term, regex, self._nodes)
        return term

    def _term(self) -> Node:
        # <term> ::= { <factor> }
        factor = None
        while self._more() and self._peek() != ')' and self._peek() != '|':
            next_factor = self._factor()
            self._nodes += 1
            factor = Node('.', factor, next_factor, self._nodes)
        return factor

    def _factor(self) -> Node:
        # <factor> ::= <base> { '*' } | <base> { '?' }
        base = self._base()
        while self._more() and (self._peek() == '*' or self._peek() == '?'):
            peek = self._peek()
            self._eat(peek)
            self._nodes += 1
            base = Node(peek, base, None, self._nodes)
        return base

    def _base(self) -> Node:
        # <base> ::= <char> | '(' <regex> ')'
        if self._peek() == '(':
            self._eat('(')
            regex = self._regex()
            self._eat(')')
            return regex
        self._nodes += 1
        return Node(self._follow(), None, None, self._nodes)


def thread_tree(root: Node) -> None:
    """ Threads the tree, making it easy to follow in order from any node """
    stack = []  # type: List[Node]
    node = root
    # traverse the tree in order
    while stack or node:
        if node:
            stack.append(node)
            node = node.left
        else:
            node = stack.pop()
            if node.right is None:
                node.right = stack[-1] if stack else Node("$", None, None, 0)
                node = None
            else:
                node = node.right


def traverse(root: Node) -> None:
    """ Sample method that traverses the threaded tree in order """
    visited = {root.symbol}
    node = root
    while node.symbol != "$":
        if node.left and node.left not in visited:
            visited.add(node.left)
            node = node.left
        else:
            print(node)
            node = node.right
